namespace container;

const vector_init_size u32 = 8;

public struct Vector
{
    var allocator Allocator;
    var count u32;
    var capacity u32;
    var elements []pointer;

    public function get(position u32) position
    {
        if (this.count <= position)
        {
            return null;
        }
        return this.elements[position];
    }
    public function set(position u32, value pointer) pointer
    {
        if (this.count <= position)
        {
            return null;
        }
        this.elements[position] = value;
        return value;
    }

    public function empty() bool
    {
        return this.count == 0;
    }
  
    public function length() u32
    {
        return this.count;
    }

    public function shrink()
    {
        if (this.capacity > 0 && this.count > 0 && this.count < this.capacity)
        {
            var address pointer = this.allocator.reallocate(this.count * size_of(pointer));
            if (address != null)
            {
                this.capacity = this.count;
                this.elements = []pointer(address);
            }
        }
    }

    public function first() pointer
    {
        if (this.count > 0)
        {
            return this.elements[0];
        }
        return null;
    }

    public function last() pointer
    {
        if (this.count > 0)
        {
            return this.elements[this.count - 1];
        }
        return null;
    }

    public function push(value pointer)
    {
        this.check_capacity();
        if (this.count < this.capacity)
        {
            this.elements[this.count] = value;
            this.count++;
        }
    }

    public function pop() pointer
    {
        if (this.count > 0)
        {
            this.count--;
            return this.elements[this.count];
        }
        return null;
    }

    public function insert(position u32, value pointer)
    {
        this.check_capacity();
        if (this.count < this.capacity)
        {
            if (position < this.count)
            {
                for (var i u32 = this.count; i > position; i--)
                {
                    this.elements[i] = this.elements[i - 1];
                }
                this.elements[position] = value;
                this.count++;
            }
        }
    }

    public function erase(position u32, destroy bool)
    {
        if (position < this.count)
        {
            if (destroy)
            {
                free(this.elements[position]);
            }
            for (var i u32 = position; i < this.count - 1; i++)
            {
                this.elements[i] = this.elements[i + 1];
            }
            this.count--;
        }
    }

    function check_capacity()
    {
        if (this.capacity == 0)
        {
            var address pointer = this.allocator.allocate(vector_init_size * size_of(pointer));
            if (address != null)
            {
                this.capacity = vector_init_size;
                this.elements = []pointer(address);
            }
        }
        if (this.count == this.capacity)
        {
            var new_capacity u32 = this.capacity * 2;
            var address pointer = this.allocator.reallocate(new_capacity * size_of(pointer));
            if (address != null)
            {
                this.capacity = new_capacity;
                this.elements = []pointer(address);
            }
        }
    }

    function clear(destroy bool)
    {
        if (destroy && this.count > 0)
        {
            for (var i u32 = 0; i < this.count; i++)
            {
                free(this.elements[i]);
            }
        }
        this.allocator.deallocate();
        this.count = 0;
        this.capacity = 0;
        this.elements = null;
    }
}