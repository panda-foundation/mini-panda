namespace container;

import libc;
import llvm;

public struct Allocator
{
    var element_size u32;
    var count u32;
    var address []u8;

    public function allocate(element_size u32, count u32) pointer
    {
        this.deallocate();
        this.address = libc.calloc(element_size, count);
        this.element_size = element_size;
        this.count = count;
        return this.address;
    }

    public function reallocate(count u32) pointer
    {
        if (this.address == null)
        {
            return this.allocate(this.element_size, count);
        }
        this.address = libc.realloc(this.address, this.element_size * count);
        if (this.count < count)
        {
            llvm.memset(&this.address[this.element_size * this.count], 0, (count - this.count) * this.element_size, true);
        }
        this.count = count;
        return this.address;
    }

    public function deallocate()
    {
        if (this.address != null)
        {
            libc.free(this.address);
            this.address = null;
            this.count = 0;
            this.element_size = 0;
        }
    }

    public function at(index u32) pointer
    {
        if (index < this.count)
        {
            return &this.address[index * this.element_size];
        }
        return null;
    }

    public function copy(from u32, to u32)
    {
        if (from < this.count && to < this.count && from != to)
        {
            llvm.memcpy(&this.address[to * this.element_size], &this.address[from * this.element_size], this.element_size, true);
        }
    }

    public function move(from u32, to u32, count u32)
    {
        if (from < this.count && to < this.count && from != to)
        {
            llvm.memmove(&this.address[to * this.element_size], &this.address[from * this.element_size], this.element_size * count, true);
        }
    }
}