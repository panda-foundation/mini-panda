namespace container;

import libc;
import llvm;

public struct Allocator
{
    var size u32;
    var count u32;
    var address pointer;

    public function allocate(size u32, count u32) pointer
    {
        this.deallocate();
        this.address = libc.calloc(size, count);
        this.size = size;
        this.count = count;
        return this.address;
    }

    public function reallocate(count u32) pointer
    {
        if (this.address == null)
        {
            return this.allocate(this.size, count);
        }
        this.address = libc.realloc(this.address, this.size * count);
        if (this.count < count)
        {
            llvm.memset(offset(this.address, this.size * this.count), 0, (count - this.count) * this.size, true);
        }
        this.count = count;
        return this.address;
    }

    public function deallocate()
    {
        if (this.address != null)
        {
            libc.free(this.address);
            this.address = null;
            this.count = 0;
            this.size = 0;
        }
    }

    public function at(index u32) pointer
    {
        if (index < this.count)
        {
            return offset(this.address, index * this.size);
        }
        return null;
    }

    public function copy(from u32, to u32)
    {
        if (from < this.count && to < this.count && from != to)
        {
            llvm.memcpy(offset(this.address, to * this.size), offset(this.address, from * this.size), this.size, true);
        }
    }

    public function move(from u32, to u32, count u32)
    {
        if (from < this.count && to < this.count && from != to)
        {
            llvm.memmove(offset(this.address, to * this.size), offset(this.address, from * this.size), this.size * count, true);
        }
    }
}